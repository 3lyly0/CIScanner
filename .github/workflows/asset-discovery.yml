name: Asset Discovery & Intelligence Gathering

on:
  workflow_dispatch:
    inputs:
      domain:
        description: 'Domain for deep recon'
        required: true
        default: 'raneen.com'
  # schedule:
    # - cron: '0 7 * * 0'

jobs:
  Recon:
    runs-on: ubuntu-latest
    env:
      DOMAIN: ${{ github.event.inputs.domain }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
     # =============================================
      # Section 1: Install Dependencies and Tools
      # =============================================

      - name: Install System Dependencies & Tools
        run: |
          # Update package list and install system-level dependencies
          sudo apt-get update
          sudo apt-get install -y chromium-browser jq libpcap-dev unzip curl \
            libnss3 libatk-bridge2.0-0 libdrm2 libxkbcommon0 libxcomposite1 \
            libxdamage1 libxrandr2 libgbm1 libxss1 libasound2t64 fonts-liberation

      - name: Install ProjectDiscovery Tools
        run: |
          echo "Installing pdtm..."
          curl -sL "https://github.com/projectdiscovery/pdtm/releases/download/v0.1.3/pdtm_0.1.3_linux_amd64.zip" -o pdtm.zip
          unzip -o pdtm.zip
          chmod +x pdtm
          sudo mv pdtm /usr/local/bin/

          echo "Installing ProjectDiscovery tools..."
          pdtm -install subfinder
          pdtm -install naabu
          pdtm -install httpx

          # Add tools to PATH
          echo "$HOME/.pdtm/go/bin" >> $GITHUB_PATH
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Install Other Tools
        run: |
          # Install Go for tools that need it
          sudo apt-get install -y golang-go

          # Install waybackurls
          echo "Installing waybackurls..."
          go install github.com/tomnomnom/waybackurls@latest

          # Install puppeteer for screenshots
          echo "Installing puppeteer..."
          npm install -g puppeteer

      # =============================================
      # Section 3: Perform Recon
      # =============================================

      - name: 1Ô∏è. Subdomain Enumeration
        run: |
          echo "üîç Enumerating subdomains for ${{ env.DOMAIN }}..."
          subfinder -d ${{ env.DOMAIN }} -silent -o subdomains.txt || {
            echo "Failed to enumerate subdomains"
            touch subdomains.txt
          }
          echo "SUBDOMAINS_COUNT=$(wc -l < subdomains.txt 2>/dev/null || echo 0)" >> $GITHUB_ENV

      - name: 2Ô∏è. Port Scanning
        run: |
          echo "üöÄ Scanning ports on discovered subdomains..."
          if [ -s subdomains.txt ]; then
            naabu -list subdomains.txt -silent -top-ports 1000 -o ports.txt || {
              echo "Failed to scan ports"
              touch ports.txt
            }
          else
            echo "No subdomains found for port scanning"
            touch ports.txt
          fi
          echo "PORTS_COUNT=$(wc -l < ports.txt 2>/dev/null || echo 0)" >> $GITHUB_ENV

      - name: 3Ô∏è. Probing & Technology Identification
        run: |
          echo "üåê Probing for live web services and identifying technologies..."
          if [ -s ports.txt ]; then
            cat ports.txt 2>/dev/null | httpx -silent -title -tech-detect -status-code -o live-services.txt || {
              echo "Failed to probe services"
              touch live-services.txt
            }
          else
            echo "No ports found for probing"
            touch live-services.txt
          fi
          echo "LIVE_SERVICES_COUNT=$(wc -l < live-services.txt 2>/dev/null || echo 0)" >> $GITHUB_ENV

      - name: 4Ô∏è. Screenshotting Live Services
        run: |
          echo "üì∏ Taking screenshots of live web services..."
          if [ -s live-services.txt ]; then
            mkdir -p screenshots
            cat live-services.txt | awk '{print $1}' | while read url; do
              filename=$(echo "$url" | sed 's|https://||;s|http://||;s|/|_|g')

              cat <<EOF > screenshot.js
                  const puppeteer = require("puppeteer");
                  (async () => {
                    try {
                      const browser = await puppeteer.launch({ args: ["--no-sandbox", "--disable-setuid-sandbox"] });
                      const page = await browser.newPage();
                      await page.goto("${url}", { waitUntil: "networkidle2", timeout: 30000 });
                      await page.screenshot({ path: "./screenshots/${filename}.png", fullPage: true });
                      await browser.close();
                    } catch (error) {
                      console.error("Error taking screenshot for ${url}:", error);
                    }
                  })();
              EOF

              node screenshot.js
            done
          else
            echo "No live services found to screenshot"
          fi

          echo "SCREENSHOTS_COUNT=$(find screenshots -name '*.png' | wc -l)" >> $GITHUB_ENV

      - name: 5. Wayback URL Gathering
        run: |
          echo "üï∞Ô∏è Gathering URLs from Wayback Machine..."
          waybackurls ${{ env.DOMAIN }} | sort -u > wayback-urls.txt || {
            echo "Failed to gather Wayback URLs"
            touch wayback-urls.txt
          }
          echo "WAYBACK_COUNT=$(wc -l < wayback-urls.txt 2>/dev/null || echo 0)" >> $GITHUB_ENV

      # =============================================
      # Section 4: Upload and Notify
      # =============================================

      - name: Send Everything (Screenshots + Report) to Discord
        env:
          # Configure how many screenshots to send directly
          MAX_IMAGES_TO_SEND: 10
          # Construct the direct URL to the artifacts section of the run
          ARTIFACT_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}#artifacts
        run: |
          # Create the ultimate notification script
          cat << 'EOF' > ultimate_notify.sh
          #!/bin/bash
          set -e

          WEBHOOK_URL="$1"
          DOMAIN="$2"
          ARTIFACT_LINK="$3"
          SCREENSHOTS_DIR="$4"
          MAX_IMAGES="$5"
          SUBDOMAINS_FILE="subdomains.txt"
          LIVE_SERVICES_FILE="live-services.txt"
          PORTS_FILE="ports.txt"
          WAYBACK_URLS_FILE="wayback-urls.txt"

          # --- Helper function to send with retries ---
          send_with_retry() {
            local payload="$1"
            local retries=3
            local wait_time=5
            for ((i=1; i<=retries; i++)); do
              echo "Attempt $i to send notification..."
              if curl -s -H "Content-Type: application/json" -X POST -d "$payload" "$WEBHOOK_URL"; then
                echo "Notification sent successfully."
                return 0
              else
                echo "Failed to send notification. Retrying in ${wait_time}s..."
                sleep $wait_time
              fi
            done
            echo "Failed to send notification after $retries attempts."
            return 1
          }

          # --- 1. Send the Main Report Embed ---
          echo "üì§ Sending main report embed..."
          SUBDOMAINS_PREVIEW=$(head -n 10 "$SUBDOMAINS_FILE" 2>/dev/null | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//' || echo "No subdomains found")
          LIVE_SERVICES_PREVIEW=$(head -n 10 "$LIVE_SERVICES_FILE" 2>/dev/null | awk '{print $1 " [" $3 "]"}' | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//' || echo "No live services found")
          PORTS_PREVIEW=$(head -n 10 "$PORTS_FILE" 2>/dev/null | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//' || echo "No ports found")
          WAYBACK_URLS_PREVIEW=$(head -n 10 "$WAYBACK_URLS_FILE" 2>/dev/null | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//' || echo "No Wayback URLs found")

          # Escape special characters for JSON
          SUBDOMAINS_PREVIEW=$(echo "$SUBDOMAINS_PREVIEW" | sed 's/\\/\\\\/g; s/\//\\\//g; s/&/\\&/g; s/\\n/\\\\n/g')
          LIVE_SERVICES_PREVIEW=$(echo "$LIVE_SERVICES_PREVIEW" | sed 's/\\/\\\\/g; s/\//\\\//g; s/&/\\&/g; s/\\n/\\\\n/g')
          PORTS_PREVIEW=$(echo "$PORTS_PREVIEW" | sed 's/\\/\\\\/g; s/\//\\\//g; s/&/\\&/g; s/\\n/\\\\n/g')
          WAYBACK_URLS_PREVIEW=$(echo "$WAYBACK_URLS_PREVIEW" | sed 's/\\/\\\\/g; s/\//\\\//g; s/&/\\&/g; s/\\n/\\\\n/g')

          PAYLOAD=$(jq -n \
            --arg title "üîç Recon Report for $DOMAIN" \
            --arg subdomains "Found **$6** subdomains. Preview: $SUBDOMAINS_PREVIEW" \
            --arg services "Found **$7** live services. Preview: $LIVE_SERVICES_PREVIEW" \
            --arg ports "Found **$8** open ports. Preview: $PORTS_PREVIEW" \
            --arg wayback "Gathered **$9** URLs from Wayback Machine. Preview: $WAYBACK_URLS_PREVIEW" \
            --arg screenshots "Took **${10}** screenshots." \
            --arg artifact "üì¶ **Download Full Report & All Files**" \
            --arg artifact_url $ARTIFACT_LINK \
            --arg footer "Recon completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
            '{
              "embeds": [ 
                {
                  "title": $title,
                  "color": 5814783,
                  "fields": [
                    {"name": "üåê Subdomains", "value": $subdomains, "inline": false},
                    {"name": "üöÄ Live Services", "value": $services, "inline": false},
                    {"name": "üîå Open Ports", "value": $ports, "inline": false},
                    {"name": "üï∞Ô∏è Wayback URLs", "value": $wayback, "inline": false},
                    {"name": "üì∏ Screenshots", "value": $screenshots, "inline": true},
                    {"name": $artifact, "value": ("[Click here to download everything](" + $artifact_url + ")"), "inline": false}
                  ],
                  "footer": {"text": $footer}
                }
              ]
            }')
          send_with_retry "$PAYLOAD"

          # --- 2. Send Screenshots as Files ---
          echo "üì∏ Sending screenshots..."
          IMAGE_COUNT=0
          TOTAL_IMAGES=$(find "$SCREENSHOTS_DIR" -name '*.png' | wc -l)

          if [ $TOTAL_IMAGES -gt 0 ]; then
            find "$SCREENSHOTS_DIR" -name '*.png' | while read -r img; do
              if (( IMAGE_COUNT >= MAX_IMAGES )); then
                break
              fi

              echo "Uploading $(basename "$img")..."
              curl -s -F "file1=@$img" -F "payload_json={\"content\": \"üì∏ Screenshot for: $(basename \"$img\" .png)\"}" "$WEBHOOK_URL"

              ((IMAGE_COUNT++))
              sleep 1 # Small delay to avoid rate limits
            done
          else
            echo "No screenshots to send"
          fi

          # --- 3. Send a follow-up if there are more images ---
          if (( TOTAL_IMAGES > MAX_IMAGES )); then
            MORE_COUNT=$((TOTAL_IMAGES - MAX_IMAGES))
            echo "üì§ Sending follow-up message for remaining screenshots..."
            FOLLOWUP_PAYLOAD=$(jq -n \
              --arg msg "There are **$MORE_COUNT** more screenshots. Download the full artifact to see them all!" \
              --arg url "$ARTIFACT_LINK" \
              '{"content": $msg + "\nüì¶ [Download All Files](" + $url + ")"}')
            send_with_retry "$FOLLOWUP_PAYLOAD"
          fi

          # --- 4. Send All Data Files ---
          echo "üì§ Sending all data files..."
          if [ -f "$SUBDOMAINS_FILE" ]; then
            curl -s -F "file1=@$SUBDOMAINS_FILE" -F "payload_json={\"content\": \"üåê Subdomains List\"}" "$WEBHOOK_URL"
            sleep 1
          fi
          if [ -f "$PORTS_FILE" ]; then
            curl -s -F "file1=@$PORTS_FILE" -F "payload_json={\"content\": \"üîå Open Ports List\"}" "$WEBHOOK_URL"
            sleep 1
          fi
          if [ -f "$LIVE_SERVICES_FILE" ]; then
            curl -s -F "file1=@$LIVE_SERVICES_FILE" -F "payload_json={\"content\": \"üöÄ Live Services List\"}" "$WEBHOOK_URL"
            sleep 1
          fi
          if [ -f "$WAYBACK_URLS_FILE" ]; then
            curl -s -F "file1=@$WAYBACK_URLS_FILE" -F "payload_json={\"content\": \"üï∞Ô∏è Wayback URLs List\"}" "$WEBHOOK_URL"
          fi

          echo "‚úÖ All notifications sent!"
          EOF
          chmod +x ultimate_notify.sh

          # Execute the script with all necessary data
          ./ultimate_notify.sh "${{ secrets.DISCORD_WEBHOOK }}" "${{ env.DOMAIN }}" "${{ env.ARTIFACT_URL }}" \
            "screenshots" "${{ env.MAX_IMAGES_TO_SEND }}" \
            "${{ env.SUBDOMAINS_COUNT }}" \
            "${{ env.LIVE_SERVICES_COUNT }}" \
            "${{ env.PORTS_COUNT }}" \
            "${{ env.WAYBACK_COUNT }}" \
            "${{ env.SCREENSHOTS_COUNT }}"

      # =============================================
      # Section 5: Cleanup
      # =============================================

      - name: Cleanup
        if: always()
        run: |
          rm -rf ultimate_notify.sh subdomains.txt ports.txt live-services.txt wayback-urls.txt screenshots/