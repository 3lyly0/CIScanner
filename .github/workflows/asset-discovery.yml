name: Asset Discovery & Intelligence Gathering

on:
  workflow_dispatch:
    inputs:
      domain:
        description: 'Domain for deep recon'
        required: true
        default: 'example.com'
  schedule:
    # Runs every Sunday at 7 AM UTC
    - cron: '0 7 * * 0'

jobs:
  recon:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install System Dependencies & Tools
        run: |
          # Update package list and install system-level dependencies
          sudo apt-get update
          # ‚úÖ SOLUTION FOR CORE DUMP: Added all necessary libraries for the headless browser
          sudo apt-get install -y chromium-browser jq libpcap-dev unzip curl \
            libnss3 libatk-bridge2.0-0 libdrm2 libxkbcommon0 libxcomposite1 \
            libxdamage1 libxrandr2 libgbm1 libxss1 libasound2 fonts-liberation
          
      - name: Install ProjectDiscovery Tools (User Path)
        run: |
          echo "Installing pdtm..."
          curl -sL "https://github.com/projectdiscovery/pdtm/releases/download/v0.1.3/pdtm_0.1.3_linux_amd64.zip" -o pdtm.zip
          unzip -o pdtm.zip
          chmod +x pdtm
          sudo mv pdtm /usr/local/bin/

          # üîß Force PDTM to use runner's home, not /root
          export PDTM_DIR="$HOME/.pdtm"
          mkdir -p "$PDTM_DIR"

          echo "Installing ProjectDiscovery tools..."
          pdtm -install subfinder
          pdtm -install naabu
          pd

          # Add tools to PATH
          echo "$HOME/.pdtm/go/bin" >> $GITHUB_PATH
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

          echo "Installed tools:"
          ls -la "$HOME/.pdtm/go/bin"

      - name: Install Other Tools (Simple Go Install & Direct Download)
        run: |
          # Install Go for tools that need it
          sudo apt-get install -y golang-go
          
          # Install waybackurls
          echo "Installing waybackurls from tom install github.com/tomnomnom/waybackurls@latest
          
          # Install aquatone (direct binary)
          echo "Installing aquatone (direct binary)..."
          curl -L -o aquatone.zip https://github.com/michenriksen/aquatone/releases/download/v1.7.0/aquatone_linux_amd64_1.7.0.zip
          unzip -o aquatone.zip
          chmod +x aquatone
          mv aquatone /usr/local/bin/aquatone
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Set Domain
        id: set_domain [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "DOMAIN=${{ github.event.inputs.domain }}" >> $GITHUB_ENV
          else
            echo "DOMAIN=example.com" >> $GITHUB_ENV
          fi

      - name: Notify Start
        run: |
          curl -s -H "Content-Type: application/json" -X POST -d "{\"content\": \"üó∫Ô∏è **Deep Recon Started for \`${{ env.DOMAIN }}\`**\"}" "${{ secrets.DISCORD_WEBHOOK }}"

      - name: 1Ô∏è‚É£ Subdomain Enumeration
        runüîç Enumerating subdomains for ${{ env.DOMAIN }}..."
          subfinder -d ${{ env.DOMAIN }} -silent -o subdomains.txt
          echo "SUBDOMAINS_COUNT=$(wc -l < subdomains.txt)" >> $GITHUB_ENV

      - name: 2Ô∏è‚É£ Port Scanning
        run: |
          echo "üöÄ Scanning ports on discovered subdomains..."
          naabu -list subdomains.txt -silent -top-ports 1000 -o ports.txt
          echo "PORTS_COUNT=$(wc -l < ports.txt)" >> $GITHUB_ENV

      - name: 3Ô∏è‚É£ Probing &: |
          echo "üåê Probing for live web services and identifying technologies..."
          cat ports.txt | httpx -silent -title -tech-detect -status-code -o live-services.txt
          echo "LIVE_SERVICES_COUNT=$(wc -l < live-services.txt)" >> $GITHUB_ENV

      - name: 4Ô∏è‚É£ Screenshotting Live Services
        run: |
          echo "üì∏ Taking screenshots of live web services..."
          mkdir -p screenshots
          # aquatone needs a list of full URLs
          cat liveprint $1}' | aquatone -out ./screenshots -threads 2 # Reduced threads to be more stable
          echo "SCREENSHOTS_COUNT=$(find screenshots -name '*.png' | wc -l)" >> $GITHUB_ENV

      - name: 5Ô∏è‚É£ Wayback URL Gathering
        run: |
          echo "üï∞Ô∏è Gathering URLs from Wayback Machine..."
          waybackurls ${{ env.DOMAIN }} | sort -u > wayback-urls.txt
          echo "WAYBACK_COUNT=$(wc -l < wayback-urls.txt)" >> $GITHUB_ENV

      - name: üì¶ Upload All Findings as Single Artifact
        uses: actions/upload-artifact@v4
        with:
          name: full-recon-report-${{ env.DOMAIN }}-${{ github.run_number }}
          path: |
            subdomains.txt
            ports.txt
            live-services.txt
            wayback-urls.txt
            screenshots/
          retention-days: 30

      - name: üì§ Send Detailed Report to Discord
        env:
          # Construct the direct URL to the artifacts section of the run
          ARTIFACT_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}#artifacts
        run: |
          # Create a new, more powerful notification script
          cat << 'EOF' > final_notify.sh
          #!/bin/bash
          set -e

          WEBHOOK_URL="$1"
          DOMAIN="$2"
          ARTIFACT_LINK="$3"
          SUBDOMAINS_FILE="subdomains.txt"
          LIVE_SERVICES_FILE="live-services.txt"
          WAYBACK_FILE="wayback-urls.txt"

          # Function to send a message with retries
          send_with_retry() {
            local payload="$1"
            local retries=3
            local wait_time=5

            for ((i=1; i<=retries; i++)); do
              echo "Attempt $i to send notification..."
              if curl -s -H "Content-Type: application/json" -X POST -d "$payload" "$WEBHOOK_URL"; then
                echo "Notification sent successfully."
                return 0
              else
                echo "Failed to send notification. Retrying in ${wait_time}s..."
                sleep $wait_time
              fi
            done
            echo "Failed to send notification after $retries attempts."
            return 1
          }

          # Prepare data for Discord
          SUBDOMAINS_PREVIEW=$(head -n 10 "$SUBDOMAINS_FILE" | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//')
          LIVE_SERVICES_PREVIEW=$(head -n 10 "$LIVE_SERVICES_FILE" | awk '{print $1 " [" $3 "]"}' | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//')

          # Build the JSON payload using jq for safety
          PAYLOAD=$(jq -n \
            --arg title "üîç Recon Report for $DOMAIN" \
            --arg subdomains "Found **$4** subdomains. Preview:\n$SUBDOMAINS_PREVIEW" \
            --arg services "Found **$5** live services. Preview:\n$LIVE_SERVICES_PREVIEW" \
            --arg wayback "Gathered **$6** URLs from Wayback Machine." \
            --arg screenshots "Took **$7** screenshots." \
            --arg artifact "üì¶ **Download Full Report & Screenshots**" \
            --arg artifact_url "$ARTIFACT_LINK" \
            --arg footer "Recon completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
            '{
              "embeds": [
                {
                  "title": $title,
                  "color": 5814783, # A nice blue color
                  "fields": [
                    {"name": "üåê Subdomains", "value": $subdomains, "inline": false},
                    {"name": "üöÄ Live Services", "value": $services, "inline": false},
                    {"name": "üï∞Ô∏è Wayback URLs", "value": $wayback, "inline": true},
                    {"name": "üì∏ Screenshots", "value": $screenshots, "inline": true},
                    {"name": $artifact, "value": "[Click here to download all files](" + $artifact_url + ")", "inline": false}
                  ],
                  "footer": {"text": $footer}
                }
              ]
            }'
          )

          # Send the final notification
          send_with_retry "$PAYLOAD"
          EOF
          chmod +x final_notify.sh

          # Execute the script with all necessary data
          ./final_notify.sh "${{ secrets.DISCORD_WEBHOOK }}" "${{ env.DOMAIN }}" "${{ env.ARTIFACT_URL }}" \
            "${{ env.SUBDOMAINS_COUNT }}" \
            "${{ env.LIVE_SERVICES_COUNT }}" \
            "${{ env.WAYBACK_COUNT }}" \
            "${{ env.SCREENSHOTS_COUNT }}"

      - name: Cleanup
        if: always()
        run: |
          rm -rf final_notify.sh subdomains.txt ports.txt live-services.txt wayback-urls.txt screenshots/
