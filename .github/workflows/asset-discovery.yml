name: Asset Discovery & Intelligence Gathering

on:
  workflow_dispatch:
    inputs:
      domain:
        description: 'Domain for deep recon'
        required: true
        default: 'raneen.com'
  # schedule:
    # - cron: '0 7 * * 0'

jobs:
  recon:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # =============================================
      # Section 1: Install Dependencies and Tools
      # =============================================

      - name: Install System Dependencies & Tools
        run: |
          # Update package list and install system-level dependencies
          sudo apt-get update
          sudo apt-get install -y chromium-browser jq libpcap-dev unzip curl \
            libnss3 libatk-bridge2.0-0 libdrm2 libxkbcommon0 libxcomposite1 \
            libxdamage1 libxrandr2 libgbm1 libxss1 libasound2t64 fonts-liberation

      - name: Install ProjectDiscovery Tools
        run: |
          echo "Installing pdtm..."
          curl -sL "https://github.com/projectdiscovery/pdtm/releases/download/v0.1.3/pdtm_0.1.3_linux_amd64.zip" -o pdtm.zip
          unzip -o pdtm.zip
          chmod +x pdtm
          sudo mv pdtm /usr/local/bin/

          echo "Installing ProjectDiscovery tools..."
          pdtm -install subfinder
          pdtm -install naabu
          pdtm -install httpx

          # Add tools to PATH
          echo "$HOME/.pdtm/go/bin" >> $GITHUB_PATH
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Install Other Tools
        run: |
          # Install Go for tools that need it
          sudo apt-get install -y golang-go

          # Install waybackurls
          echo "Installing waybackurls..."
          go install github.com/tomnomnom/waybackurls@latest

          # Install aquatone
          echo "Installing aquatone..."
          curl -L -o aquatone.zip https://github.com/michenriksen/aquatone/releases/download/v1.7.0/aquatone_linux_amd64_1.7.0.zip
          unzip -o aquatone.zip
          chmod +x aquatone
          sudo mv aquatone /usr/local/bin/aquatone
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      # =============================================
      # Section 2: Set Domain and Notify Start
      # =============================================

      - name: Set Domain
        id: set_domain
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "DOMAIN=${{ github.event.inputs.domain }}" >> $GITHUB_ENV
          else
            echo "DOMAIN=example.com" >> $GITHUB_ENV
          fi

      - name: Notify Start
        run: |
          curl -s -H "Content-Type: application/json" -X POST -d "{\"content\": \"üó∫Ô∏è **Deep Recon Started for \`${{ env.DOMAIN }}\`**\"}" "${{ secrets.DISCORD_WEBHOOK }}"

      # =============================================
      # Section 3: Perform Recon
      # =============================================

      - name: 1Ô∏è. Subdomain Enumeration
        run: |
          echo "üîç Enumerating subdomains for ${{ env.DOMAIN }}..."
          subfinder -d ${{ env.DOMAIN }} -silent -o subdomains.txt
          echo "SUBDOMAINS_COUNT=$(wc -l < subdomains.txt)" >> $GITHUB_ENV

      - name: 2Ô∏è. Port Scanning
        run: |
          echo "üöÄ Scanning ports on discovered subdomains..."
          naabu -list subdomains.txt -silent -top-ports 1000 -o ports.txt
          echo "PORTS_COUNT=$(wc -l < ports.txt)" >> $GITHUB_ENV

      - name: 3Ô∏è. Probing & Technology Identification
        run: |
          echo "üåê Probing for live web services and identifying technologies..."
          cat ports.txt | httpx -silent -title -tech-detect -status-code -o live-services.txt
          echo "LIVE_SERVICES_COUNT=$(wc -l < live-services.txt)" >> $GITHUB_ENV

      - name: 4Ô∏è. Screenshotting Live Services
        run: |
          echo "üì∏ Taking screenshots of live web services..."
          mkdir -p screenshots
          # aquatone needs a list of full URLs. Reduced threads for stability.
          cat live-services.txt | awk '{print $1}' | aquatone -out ./screenshots -threads 2
          echo "SCREENSHOTS_COUNT=$(find screenshots -name '*.png' | wc -l)" >> $GITHUB_ENV

      - name: 5. Wayback URL Gathering
        run: |
          echo "üï∞Ô∏è Gathering URLs from Wayback Machine..."
          waybackurls ${{ env.DOMAIN }} | sort -u > wayback-urls.txt
          echo "WAYBACK_COUNT=$(wc -l < wayback-urls.txt)" >> $GITHUB_ENV

      # =============================================
      # Section 4: Upload and Notify
      # =============================================

      - name: üì¶ Upload All Findings as Single Artifact
        uses: actions/upload-artifact@v4
        with:
          name: full-recon-report-${{ env.DOMAIN }}-${{ github.run_number }}
          path: |
            subdomains.txt
            ports.txt
            live-services.txt
            wayback-urls.txt
            screenshots/
          retention-days: 30

      - name: üì§ Send Everything (Screenshots + Report) to Discord
        env:
          # Configure how many screenshots to send directly
          MAX_IMAGES_TO_SEND: 10
          # Construct the direct URL to the artifacts section of the run
          ARTIFACT_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}#artifacts
        run: |
          # Create the ultimate notification script
          cat << 'EOF' > ultimate_notify.sh
          #!/bin/bash
          set -e

          WEBHOOK_URL="$1"
          DOMAIN="$2"
          ARTIFACT_LINK="$3"
          SCREENSHOTS_DIR="$4"
          MAX_IMAGES="$5"
          SUBDOMAINS_FILE="subdomains.txt"
          LIVE_SERVICES_FILE="live-services.txt"
          PORTS_FILE="ports.txt"
          WAYBACK_URLS_FILE="wayback-urls.txt"

          # --- Helper function to send with retries ---
          send_with_retry() {
            local payload="$1"
            local retries=3
            local wait_time=5
            for ((i=1; i<=retries; i++)); do
              echo "Attempt $i to send notification..."
              if curl -s -H "Content-Type: application/json" -X POST -d "$payload" "$WEBHOOK_URL"; then
                echo "Notification sent successfully."
                return 0
              else
                echo "Failed to send notification. Retrying in ${wait_time}s..."
                sleep $wait_time
              fi
            done
            echo "Failed to send notification after $retries attempts."
            return 1
          }

          # --- 1. Send the Main Report Embed ---
          echo "üì§ Sending main report embed..."
          SUBDOMAINS_PREVIEW=$(head -n 10 "$SUBDOMAINS_FILE" | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//')
          LIVE_SERVICES_PREVIEW=$(head -n 10 "$LIVE_SERVICES_FILE" | awk '{print $1 " [" $3 "]"}' | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//')
          PORTS_PREVIEW=$(head -n 10 "$PORTS_FILE" | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//')
          WAYBACK_URLS_PREVIEW=$(head -n 10 "$WAYBACK_URLS_FILE" | sed 's/^/- /' | tr '\n' '; ' | sed 's/; $//')

          PAYLOAD=$(jq -n \
            --arg title "üîç Recon Report for $DOMAIN" \
            --arg subdomains "Found **$6** subdomains. Preview:\n$SUBDOMAINS_PREVIEW" \
            --arg services "Found **$7** live services. Preview:\n$LIVE_SERVICES_PREVIEW" \
            --arg ports "Found **$8** open ports. Preview:\n$PORTS_PREVIEW" \
            --arg wayback "Gathered **$9** URLs from Wayback Machine. Preview:\n$WAYBACK_URLS_PREVIEW" \
            --arg screenshots "Took **$10** screenshots." \
            --arg artifact "üì¶ **Download Full Report & All Files**" \
            --arg artifact_url "$ARTIFACT_LINK" \
            --arg footer "Recon completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
            '{
              "embeds": [
                {
                  "title": $title,
                  "color": 5814783,
                  "fields": [
                    {"name": "üåê Subdomains", "value": $subdomains, "inline": false},
                    {"name": "üöÄ Live Services", "value": $services, "inline": false},
                    {"name": "üîå Open Ports", "value": $ports, "inline": false},
                    {"name": "üï∞Ô∏è Wayback URLs", "value": $wayback, "inline": false},
                    {"name": "üì∏ Screenshots", "value": $screenshots, "inline": true},
                    {"name": $artifact, "value": "[Click here to download everything](\($artifact_url))", "inline": false}
                  ],
                  "footer": {"text": $footer}
                }
              ]
            }')
          send_with_retry "$PAYLOAD"

          # --- 2. Send Screenshots as Files ---
          echo "üì∏ Sending screenshots..."
          IMAGE_COUNT=0
          TOTAL_IMAGES=$(find "$SCREENSHOTS_DIR" -name '*.png' | wc -l)

          find "$SCREENSHOTS_DIR" -name '*.png' | while read -r img; do
            if (( IMAGE_COUNT >= MAX_IMAGES )); then
              break
            fi

            echo "Uploading $(basename "$img")..."
            curl -s -F "file1=@$img" -F "payload_json={\"content\": \"üì∏ Screenshot for: $(basename "$img" .png)\"}" "$WEBHOOK_URL"

            ((IMAGE_COUNT++))
            sleep 1 # Small delay to avoid rate limits
          done

          # --- 3. Send a follow-up if there are more images ---
          if (( TOTAL_IMAGES > MAX_IMAGES )); then
            MORE_COUNT=$((TOTAL_IMAGES - MAX_IMAGES))
            echo "üì§ Sending follow-up message for remaining screenshots..."
            FOLLOWUP_PAYLOAD=$(jq -n \
              --arg msg "There are **$MORE_COUNT** more screenshots. Download the full artifact to see them all!" \
              --arg url "$ARTIFACT_LINK" \
              '{"content": $msg + "\nüì¶ [Download All Files](" + $url + ")"}')
            send_with_retry "$FOLLOWUP_PAYLOAD"
          fi

          # --- 4. Send All Data Files ---
          echo "üì§ Sending all data files..."
          curl -s -F "file1=@$SUBDOMAINS_FILE" -F "payload_json={\"content\": \"üåê Subdomains List\"}" "$WEBHOOK_URL"
          sleep 1
          curl -s -F "file1=@$PORTS_FILE" -F "payload_json={\"content\": \"üîå Open Ports List\"}" "$WEBHOOK_URL"
          sleep 1
          curl -s -F "file1=@$LIVE_SERVICES_FILE" -F "payload_json={\"content\": \"üöÄ Live Services List\"}" "$WEBHOOK_URL"
          sleep 1
          curl -s -F "file1=@$WAYBACK_URLS_FILE" -F "payload_json={\"content\": \"üï∞Ô∏è Wayback URLs List\"}" "$WEBHOOK_URL"

          echo "‚úÖ All notifications sent!"
          EOF
          chmod +x ultimate_notify.sh

          # Execute the script with all necessary data
          ./ultimate_notify.sh "${{ secrets.DISCORD_WEBHOOK }}" "${{ env.DOMAIN }}" "${{ env.ARTIFACT_URL }}" \
            "screenshots" "${{ env.MAX_IMAGES_TO_SEND }}" \
            "${{ env.SUBDOMAINS_COUNT }}" \
            "${{ env.LIVE_SERVICES_COUNT }}" \
            "${{ env.PORTS_COUNT }}" \
            "${{ env.WAYBACK_COUNT }}" \
            "${{ env.SCREENSHOTS_COUNT }}"

      # =============================================
      # Section 5: Cleanup
      # =============================================

      - name: Cleanup
        if: always()
        run: |
          rm -rf ultimate_notify.sh subdomains.txt ports.txt live-services.txt wayback-urls.txt screenshots/