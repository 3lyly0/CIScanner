name: Subdomain Monitor

on:
  schedule:
    # Runs every 3 hours
    - cron: '0 */3 * * *'
  workflow_dispatch:
    inputs:
      domain:
        description: 'Target domain to scan'
        required: true
        default: 'raneen.com'

# Set permissions for the workflow
permissions:
  contents: write

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          clean: true
          fetch-depth: 1

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Install subfinder
        run: |
          go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Verify installation
        run: subfinder -version

      - name: Run subfinder
        env:
          DOMAIN: ${{ github.event.inputs.domain || 'example.com' }}
        run: |
          subfinder -d "$DOMAIN" -silent -o current-subdomains.txt
          echo "SUBDOMAINS_COUNT=$(wc -l < current-subdomains.txt)" >> $GITHUB_ENV

      - name: Check for previous results
        id: check_previous
        run: |
          if [ -f previous-subdomains.txt ]; then
            echo "previous_exists=true" >> $GITHUB_OUTPUT
            echo "PREVIOUS_COUNT=$(wc -l < previous-subdomains.txt)" >> $GITHUB_ENV
          else
            echo "previous_exists=false" >> $GITHUB_OUTPUT
            echo "PREVIOUS_COUNT=0" >> $GITHUB_ENV
          fi

      - name: Compare with previous results
        if: steps.check_previous.outputs.previous_exists == 'true'
        run: |
          sort -u current-subdomains.txt > current-sorted.txt
          sort -u previous-subdomains.txt > previous-sorted.txt
          comm -23 current-sorted.txt previous-sorted.txt > new-subdomains.txt
          echo "NEW_COUNT=$(wc -l < new-subdomains.txt)" >> $GITHUB_ENV
          comm -13 current-sorted.txt previous-sorted.txt > removed-subdomains.txt
          echo "REMOVED_COUNT=$(wc -l < removed-subdomains.txt)" >> $GITHUB_ENV

      - name: Prepare for first run
        if: steps.check_previous.outputs.previous_exists == 'false'
        run: |
          echo "NEW_COUNT=0" >> $GITHUB_ENV
          echo "REMOVED_COUNT=0" >> $GITHUB_ENV
          touch new-subdomains.txt removed-subdomains.txt

      - name: Create Discord notification script
        run: |
          cat << 'EOF' > send_notifications.sh
          #!/bin/bash
          set -e

          WEBHOOK_URL="$1"
          DOMAIN="$2"
          CURRENT_FILE="$3"
          NEW_FILE="$4"
          REMOVED_FILE="$5"

          # --- Helper function to send a Discord embed ---
          send_embed() {
              local title="$1"
              local description="$2"
              local color="$3"
              local footer_text="$4"

              # The description variable now contains actual newline characters
              local payload
              payload=$(jq -n \
                  --arg title "$title" \
                  --arg description "$description" \
                  --argjson color "$color" \
                  --arg footer "$footer_text" \
                  '{
                      "embeds": [{
                          "title": $title,
                          "description": $description,
                          "color": $color,
                          "footer": {"text": $footer}
                      }]
                  }')
              
              curl -s -H "Content-Type: application/json" -X POST -d "$payload" "$WEBHOOK_URL"
          }

          # --- Helper function to send a long list in chunks ---
          send_list_in_chunks() {
              local file_path="$1"
              local list_title="$2"
              local color="$3"
              
              if [ ! -f "$file_path" ] || [ ! -s "$file_path" ]; then
                  return
              fi

              local total_lines
              total_lines=$(wc -l < "$file_path")
              local part_num=1
              local chunk=""
              local DISCORD_FIELD_LIMIT=1000

              while IFS= read -r line; do
                  # Use printf to build the chunk with actual newlines
                  local new_chunk
                  printf -v new_chunk '%s%s\n' "$chunk" "$line"

                  if [ ${#new_chunk} -gt $DISCORD_FIELD_LIMIT ]; then
                      # If the new chunk is too big, send the old one
                      local description
                      printf -v description '```\n%s\n```' "$chunk"
                      send_embed "$list_title (Part $part_num)" "$description" "$color" "Total items: $total_lines"
                      
                      # Start a new chunk with the current line
                      printf -v chunk '%s\n' "$line"
                      ((part_num++))
                  else
                      # If not too big, update the chunk
                      chunk="$new_chunk"
                  fi
              done < "$file_path"

              # Send the last remaining chunk
              if [ -n "$chunk" ]; then
                  local description
                  printf -v description '```\n%s\n```' "$chunk"
                  send_embed "$list_title (Part $part_num)" "$description" "$color" "Total items: $total_lines"
              fi
          }

          # --- Main Execution ---

          # 1. Send Summary Report
          # Use printf to create the description with actual newlines
          summary_desc=""
          printf -v summary_desc '**Total Current:** %s\n**Previous:** %s\n**New:** %s\n**Removed:** %s' "$SUBDOMAINS_COUNT" "$PREVIOUS_COUNT" "$NEW_COUNT" "$REMOVED_COUNT"
          send_embed "Subdomain Report for $DOMAIN" "$summary_desc" "5814783" "Scan completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

          # 2. Send New Subdomains (if any)
          if [ "$NEW_COUNT" -gt 0 ]; then
              send_list_in_chunks "$NEW_FILE" "🆕 New Subdomains" "5763719" # Green
          fi

          # 3. Send Removed Subdomains (if any)
          if [ "$REMOVED_COUNT" -gt 0 ]; then
              send_list_in_chunks "$REMOVED_FILE" "❌ Removed Subdomains" "15548997" # Red
          fi

          # 4. Send Full Current List (optional)
          # Uncomment the following line if you want to receive the full list every time
          # send_list_in_chunks "$CURRENT_FILE" "📄 Full Current Subdomain List" "10181038" # Grey
          EOF
          chmod +x send_notifications.sh

      - name: Send Discord notifications
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK}}
          DOMAIN: ${{ github.event.inputs.domain || 'example.com' }}
          SUBDOMAINS_COUNT: ${{ env.SUBDOMAINS_COUNT }}
          PREVIOUS_COUNT: ${{ env.PREVIOUS_COUNT }}
          NEW_COUNT: ${{ env.NEW_COUNT }}
          REMOVED_COUNT: ${{ env.REMOVED_COUNT }}
        run: |
          ./send_notifications.sh "$WEBHOOK_URL" "$DOMAIN" current-subdomains.txt new-subdomains.txt removed-subdomains.txt

      - name: Update previous results
        run: |
          cp current-subdomains.txt previous-subdomains.txt

      - name: Commit and push changes
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add previous-subdomains.txt
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update previous subdomains list"
            git push origin main
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f current-subdomains.txt previous-subdomains.txt new-subdomains.txt removed-subdomains.txt current-sorted.txt previous-sorted.txt send_notifications.sh
