name: Subdomain Monitor

on:
  schedule:
    # Runs every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      domain:
        description: 'Target domain to scan'
        required: true
        default: 'example.com'

# Set permissions for the workflow
permissions:
  contents: write

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          clean: true
          fetch-depth: 1

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Install subfinder
        run: |
          go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Verify installation
        run: subfinder -version

      - name: Run subfinder
        env:
          DOMAIN: ${{ github.event.inputs.domain || 'example.com' }}
        run: |
          subfinder -d "$DOMAIN" -silent -o current-subdomains.txt
          echo "SUBDOMAINS_COUNT=$(wc -l < current-subdomains.txt)" >> $GITHUB_ENV

      - name: Check for previous results
        id: check_previous
        run: |
          if [ -f previous-subdomains.txt ]; then
            echo "previous_exists=true" >> $GITHUB_OUTPUT
            echo "PREVIOUS_COUNT=$(wc -l < previous-subdomains.txt)" >> $GITHUB_ENV
          else
            echo "previous_exists=false" >> $GITHUB_OUTPUT
            echo "PREVIOUS_COUNT=0" >> $GITHUB_ENV
          fi

      # --- CORRECTED SECTION ---
      # This step runs ONLY if previous results exist
      - name: Compare with previous results
        if: steps.check_previous.outputs.previous_exists == 'true'
        run: |
          # Sort both files and find new subdomains
          sort -u current-subdomains.txt > current-sorted.txt
          sort -u previous-subdomains.txt > previous-sorted.txt
          comm -23 current-sorted.txt previous-sorted.txt > new-subdomains.txt
          echo "NEW_COUNT=$(wc -l < new-subdomains.txt)" >> $GITHUB_ENV
          
          # Also find removed subdomains
          comm -13 current-sorted.txt previous-sorted.txt > removed-subdomains.txt
          echo "REMOVED_COUNT=$(wc -l < removed-subdomains.txt)" >> $GITHUB_ENV

      # This step runs ONLY if it's the first time (no previous results)
      - name: Prepare for first run
        if: steps.check_previous.outputs.previous_exists == 'false'
        run: |
          echo "NEW_COUNT=0" >> $GITHUB_ENV
          echo "REMOVED_COUNT=0" >> $GITHUB_ENV
          # Create empty files so the notification script doesn't fail
          touch new-subdomains.txt removed-subdomains.txt
      # --- END OF CORRECTED SECTION ---

      - name: Create Discord notification script
        run: |
          cat << 'EOF' > send_notifications.sh
          #!/bin/bash
          set -e # Exit immediately if a command exits with a non-zero status.

          WEBHOOK_URL="$1"
          DOMAIN="$2"
          CURRENT_FILE="$3"
          NEW_FILE="$4"
          REMOVED_FILE="$5"

          # --- Helper function to send a Discord embed ---
          send_embed() {
            local title="$1"
            local description="$2"
            local color="$3"
            local footer_text="$4"

            local payload
            payload=$(jq -n \
              --arg title "$title" \
              --arg description "$description" \
              --argjson color "$color" \
              --arg footer "$footer_text" \
              '{
                "embeds": [{
                  "title": $title,
                  "description": $description,
                  "color": $color,
                  "footer": {"text": $footer}
                }]
              }')
            
            curl -s -H "Content-Type: application/json" -X POST -d "$payload" "$WEBHOOK_URL"
          }

          # --- Helper function to send a long list in chunks ---
          send_list_in_chunks() {
            local file_path="$1"
            local list_title="$2"
            local color="$3"
            
            if [ ! -f "$file_path" ] || [ ! -s "$file_path" ]; then
              return # Skip if file doesn't exist or is empty
            fi

            local total_lines
            total_lines=$(wc -l < "$file_path")
            local part_num=1
            local chunk=""
            local DISCORD_FIELD_LIMIT=1000 # Conservative limit for a field value

            while IFS= read -r line; do
              # Check if adding the next line exceeds the limit
              if [ ${#chunk} -gt $DISCORD_FIELD_LIMIT ]; then
                send_embed "$list_title (Part $part_num)" "```\n$chunk\n```" "$color" "Total items: $total_lines"
                chunk="$line"
                ((part_num++))
              else
                chunk+="$line\n"
              fi
            done < "$file_path"

            # Send the last remaining chunk
            if [ -n "$chunk" ]; then
              send_embed "$list_title (Part $part_num)" "```\n$chunk\n```" "$color" "Total items: $total_lines"
            fi
          }

          # --- Main Execution ---

          # 1. Send Summary Report
          summary_desc="**Total Current:** $SUBDOMAINS_COUNT\n**Previous:** $PREVIOUS_COUNT\n**New:** $NEW_COUNT\n**Removed:** $REMOVED_COUNT"
          send_embed "Subdomain Report for $DOMAIN" "$summary_desc" "5814783" "Scan completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

          # 2. Send New Subdomains (if any)
          if [ "$NEW_COUNT" -gt 0 ]; then
            send_list_in_chunks "$NEW_FILE" "🆕 New Subdomains" "5763719" # Green
          fi

          # 3. Send Removed Subdomains (if any)
          if [ "$REMOVED_COUNT" -gt 0 ]; then
            send_list_in_chunks "$REMOVED_FILE" "❌ Removed Subdomains" "15548997" # Red
          fi

          # 4. Send Full Current List (optional, can be very long)
          # Uncomment the following line if you want to receive the full list every time
          # send_list_in_chunks "$CURRENT_FILE" "📄 Full Current Subdomain List" "10181038" # Grey
          EOF
          chmod +x send_notifications.sh

      - name: Send Discord notifications
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK}}
          DOMAIN: ${{ github.event.inputs.domain || 'example.com' }}
          SUBDOMAINS_COUNT: ${{ env.SUBDOMAINS_COUNT }}
          PREVIOUS_COUNT: ${{ env.PREVIOUS_COUNT }}
          NEW_COUNT: ${{ env.NEW_COUNT }}
          REMOVED_COUNT: ${{ env.REMOVED_COUNT }}
        run: |
          ./send_notifications.sh "$WEBHOOK_URL" "$DOMAIN" current-subdomains.txt new-subdomains.txt removed-subdomains.txt

      - name: Update previous results
        run: |
          cp current-subdomains.txt previous-subdomains.txt

      - name: Commit and push changes
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add previous-subdomains.txt
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update previous subdomains list"
            git push origin main
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f current-subdomains.txt previous-subdomains.txt new-subdomains.txt removed-subdomains.txt current-sorted.txt previous-sorted.txt send_notifications.sh
